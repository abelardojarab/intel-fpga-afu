// (C) 2001-2018 Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions and other 
// software and tools, and its AMPP partner logic functions, and any output 
// files from any of the foregoing (including device programming or simulation 
// files), and any associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License Subscription 
// Agreement, Intel FPGA IP License Agreement, or other applicable 
// license agreement, including, without limitation, that your use is for the 
// sole purpose of programming logic devices manufactured by Intel and sold by 
// Intel or its authorized distributors.  Please refer to the applicable 
// agreement for further details.


// Copyright 2014 Altera Corporation. All rights reserved.
// Altera products are protected under numerous U.S. and foreign patents, 
// maskwork rights, copyrights and other intellectual property laws.  
//
// This reference design file, and your use thereof, is subject to and governed
// by the terms and conditions of the applicable Altera Reference Design 
// License Agreement (either as signed by you or found at www.altera.com).  By
// using this reference design file, you indicate your acceptance of such terms
// and conditions between you and Altera Corporation.  In the event that you do
// not agree with such terms and conditions, you may not use the reference 
// design file and please promptly destroy any copies you have made.
//
// This reference design file is being provided on an "as-is" basis and as an 
// accommodation and therefore all warranties, representations or guarantees of 
// any kind (whether express, implied or statutory) including, without 
// limitation, warranties of merchantability, non-infringement, or fitness for
// a particular purpose, are specifically disclaimed.  By making this reference
// design file available, Altera expressly does not recommend, suggest or 
// require that this reference design file be used in combination with any 
// other product not provided by Altera.
/////////////////////////////////////////////////////////////////////////////


`timescale 1ps/1ps

// DESCRIPTION
// MLAB with 128 bit words.  4 addr lines.
// Generated by one of Gregg's toys.   Share And Enjoy.

module alt_e100s10_mlab128a4r1w1 #(
    parameter SIM_EMULATE = 1'b0
) (
    input wclk,
    input [3:0] waddr,
    input [127:0] din,
    input rclk,
    input [3:0] raddr,
    output [127:0] dout
);

////////////////////////////
// handle data bits 19..0

reg [3:0] waddr_m0 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m0 <= waddr;

reg [19:0] wdata_m0 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m0 <= din[19:0];

reg [3:0] raddr_m0 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m0 <= raddr;

alt_e100s10_mlab m0 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m0),
	.wdata_reg(wdata_m0),
	.raddr(raddr_m0),
	.rdata(dout[19:0])
);
defparam m0 .WIDTH = 20;
defparam m0 .ADDR_WIDTH = 4;
defparam m0 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 39..20

reg [3:0] waddr_m1 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m1 <= waddr;

reg [19:0] wdata_m1 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m1 <= din[39:20];

reg [3:0] raddr_m1 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m1 <= raddr;

alt_e100s10_mlab m1 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m1),
	.wdata_reg(wdata_m1),
	.raddr(raddr_m1),
	.rdata(dout[39:20])
);
defparam m1 .WIDTH = 20;
defparam m1 .ADDR_WIDTH = 4;
defparam m1 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 59..40

reg [3:0] waddr_m2 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m2 <= waddr;

reg [19:0] wdata_m2 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m2 <= din[59:40];

reg [3:0] raddr_m2 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m2 <= raddr;

alt_e100s10_mlab m2 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m2),
	.wdata_reg(wdata_m2),
	.raddr(raddr_m2),
	.rdata(dout[59:40])
);
defparam m2 .WIDTH = 20;
defparam m2 .ADDR_WIDTH = 4;
defparam m2 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 79..60

reg [3:0] waddr_m3 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m3 <= waddr;

reg [19:0] wdata_m3 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m3 <= din[79:60];

reg [3:0] raddr_m3 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m3 <= raddr;

alt_e100s10_mlab m3 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m3),
	.wdata_reg(wdata_m3),
	.raddr(raddr_m3),
	.rdata(dout[79:60])
);
defparam m3 .WIDTH = 20;
defparam m3 .ADDR_WIDTH = 4;
defparam m3 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 99..80

reg [3:0] waddr_m4 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m4 <= waddr;

reg [19:0] wdata_m4 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m4 <= din[99:80];

reg [3:0] raddr_m4 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m4 <= raddr;

alt_e100s10_mlab m4 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m4),
	.wdata_reg(wdata_m4),
	.raddr(raddr_m4),
	.rdata(dout[99:80])
);
defparam m4 .WIDTH = 20;
defparam m4 .ADDR_WIDTH = 4;
defparam m4 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 119..100

reg [3:0] waddr_m5 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m5 <= waddr;

reg [19:0] wdata_m5 = 20'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m5 <= din[119:100];

reg [3:0] raddr_m5 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m5 <= raddr;

alt_e100s10_mlab m5 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m5),
	.wdata_reg(wdata_m5),
	.raddr(raddr_m5),
	.rdata(dout[119:100])
);
defparam m5 .WIDTH = 20;
defparam m5 .ADDR_WIDTH = 4;
defparam m5 .SIM_EMULATE = SIM_EMULATE;

////////////////////////////
// handle data bits 127..120

reg [3:0] waddr_m6 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) waddr_m6 <= waddr;

reg [7:0] wdata_m6 = 8'b0 /* synthesis preserve_syn_only */;
always @(posedge wclk) wdata_m6 <= din[127:120];

reg [3:0] raddr_m6 = 4'b0 /* synthesis preserve_syn_only */;
always @(posedge rclk) raddr_m6 <= raddr;

alt_e100s10_mlab m6 (
	.wclk(wclk),
	.wena(1'b1),
	.waddr_reg(waddr_m6),
	.wdata_reg(wdata_m6),
	.raddr(raddr_m6),
	.rdata(dout[127:120])
);
defparam m6 .WIDTH = 8;
defparam m6 .ADDR_WIDTH = 4;
defparam m6 .SIM_EMULATE = SIM_EMULATE;

endmodule

