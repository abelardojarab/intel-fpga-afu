// (C) 2001-2018 Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions and other 
// software and tools, and its AMPP partner logic functions, and any output 
// files from any of the foregoing (including device programming or simulation 
// files), and any associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License Subscription 
// Agreement, Intel FPGA IP License Agreement, or other applicable 
// license agreement, including, without limitation, that your use is for the 
// sole purpose of programming logic devices manufactured by Intel and sold by 
// Intel or its authorized distributors.  Please refer to the applicable 
// agreement for further details.




`timescale 1ps/1ps

// DESCRIPTION
// Ethernet 64-66 block encoder.
// Generated by one of Gregg's toys.   Share And Enjoy.

module alt_e100s10_ethenc #(
    parameter SIM_EMULATE = 1'b0
) (
        input clk, 
        input [7:0] din_c,
        input [63:0] din_d, // bit 0 first
        output [65:0] dout
);

// Note -
// This is an Ethernet 64/66 encoder operating with the assumption that the TX MAC only sends legal MII
// traffic. The assumption greatly reduces the logic cost, although it will not follow the letter of the
// specification if operated standalone and given an illegal MII sequence (e.g. SOP,SOP,SOP). If the traffic
// is illegal the encoding will be best-effort (but your TX MAC isn't working properly, so there is a larger
// issue to resolve).

localparam MII_IDLE = 8'h7,            // I
        MII_START = 8'hfb,            // S
        MII_TERMINATE = 8'hfd,        // T
        MII_ERROR = 8'hfe,            // E
        MII_SEQ_ORDERED = 8'h9c,    // Q aka O
        MII_SIG_ORDERED = 8'h5c;    // Fsig aka O
        
localparam BLK_CTRL = 8'h1e,
            BLK_START = 8'h78,
            BLK_OS_A =  8'h4b,    // for Q
            BLK_OS_B =  8'h55,    // for Fsig
            BLK_TERM0 = 8'h87,
            BLK_TERM1 = 8'h99,
            BLK_TERM2 = 8'haa,
            BLK_TERM3 = 8'hb4,
            BLK_TERM4 = 8'hcc,
            BLK_TERM5 = 8'hd2,
            BLK_TERM6 = 8'he1,
            BLK_TERM7 = 8'hff;
            
localparam EBLOCK_T = {{8{7'h1e}},BLK_CTRL,2'b01};
localparam IBLOCK_T = {{8{7'h00}},BLK_CTRL,2'b01};

///////////////////////////////////////////////////
// comparators on the MII input bytes

wire m_error;
alt_e100s10_eqc9h1fet2 cmp_err (
    .clk(clk),
    .din({din_c[7],din_d[63:56]}),
    .dout(m_error)
);
defparam cmp_err .SIM_EMULATE = SIM_EMULATE;

wire m_start;
alt_e100s10_eqc9h1fbt2 cmp0 (
    .clk(clk),
    .din({din_c[0],din_d[7:0]}),
    .dout(m_start)
);
defparam cmp0 .SIM_EMULATE = SIM_EMULATE;


wire [7:0] m_term;
genvar i;
generate 
        for (i=0; i<8; i=i+1) begin : t
        alt_e100s10_eqc9h1fdt2 cmp1 (
            .clk(clk),
            .din({din_c[i],din_d[8*(i+1)-1:8*i]}),
            .dout(m_term[i])
        );
        defparam cmp1 .SIM_EMULATE = SIM_EMULATE;

        end
endgenerate

wire m_any_control;
alt_e100s10_or8t2 c0 (
    .clk(clk),
    .din(din_c),
    .dout(m_any_control)
);
defparam c0 .SIM_EMULATE = SIM_EMULATE;


wire m_all_control;
alt_e100s10_and8t2 c1 (
    .clk(clk),
    .din(din_c),
    .dout(m_all_control)
);
defparam c1 .SIM_EMULATE = SIM_EMULATE;

wire m_seq;
alt_e100s10_eq_10_const eqs(
        .clk(clk),
        .din({1'b0, din_c[0],din_d[7:0]}),
        .match(m_seq)
);
//defparam eqs .VAL = {1'b0,1'b1,MII_SEQ_ORDERED};
localparam VALUE = {1'b0,1'b1,MII_SEQ_ORDERED};
defparam eqs .VAL = VALUE;

defparam eqs .TARGET_CHIP = 5; // 0 generic, 1=S4, 2=S5, 3=A5, 4=C5, 5=A10
   
///////////////////////////////////////////////////
// figure out what you want to show

reg [3:0] block_sel = 4'b0;
always @(posedge clk) begin
        block_sel[0] <= m_term[1] | m_term[3] | m_term[5] | m_term[7] | !m_any_control | m_error;
        block_sel[1] <= m_term[2] | m_term[3] | m_term[6] | m_term[7] | m_start | m_error;
        block_sel[2] <= m_term[4] | m_term[5] | m_term[6] | m_term[7] | m_seq | m_error;
        block_sel[3] <= (!m_term[0] & (!m_any_control | m_start | m_all_control | m_seq ))| m_error;
end

///////////////////////////////////////////////////
// match up latency

wire [63:0] raw_data;

alt_e100s10_delay3w64 d0 (
    .clk(clk),
    .din(din_d),
    .dout(raw_data)
);
defparam d0 .SIM_EMULATE = SIM_EMULATE;

        
///////////////////////////////////////////////////
// output MUX

wire [55:0] packed_control = 56'h0; // idle is 0

reg [65:0] encoded_block = 66'b0 /* synthesis preserve_syn_only */;
always @(posedge clk) begin
        case (block_sel)
                4'h0 : encoded_block <= {packed_control[55:7],7'b0,BLK_TERM0,2'b01};
                4'h1 : encoded_block <= {packed_control[55:14],6'b0,raw_data[7:0],BLK_TERM1,2'b01};
                4'h2 : encoded_block <= {packed_control[55:21],5'b0,raw_data[15:0],BLK_TERM2,2'b01};
                4'h3 : encoded_block <= {packed_control[55:28],4'b0,raw_data[23:0],BLK_TERM3,2'b01};
                4'h4 : encoded_block <= {packed_control[55:35],3'b0,raw_data[31:0],BLK_TERM4,2'b01};
                4'h5 : encoded_block <= {packed_control[55:42],2'b0,raw_data[39:0],BLK_TERM5,2'b01};
                4'h6 : encoded_block <= {packed_control[55:49],1'b0,raw_data[47:0],BLK_TERM6,2'b01};
                4'h7 : encoded_block <= {raw_data[55:0],BLK_TERM7,2'b01};
                4'h8 : encoded_block <= IBLOCK_T;
                4'h9 : encoded_block <= {raw_data,2'b10};
                4'ha : encoded_block <= {raw_data[63:8],BLK_START,2'b01};
                4'hb : encoded_block <= EBLOCK_T;
                4'hc : encoded_block <= {raw_data[63:8],BLK_OS_A,2'b01};
                4'hd : encoded_block <= EBLOCK_T;
                4'he : encoded_block <= EBLOCK_T;
                4'hf : encoded_block <= EBLOCK_T;
        endcase         
end
assign dout = encoded_block;
endmodule

